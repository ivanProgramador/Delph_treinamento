unit unitPrincipal;



interface

{Dentro da sessão uses fica a importação das classes que serão usadas dentro do côdigo}
uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;

{
  aqui eu informo para o compilador o tipo dos meus componentes
  por exemplo:
  Na minha tela vai ter o componente  "txtResultado" porém o compilador não sabe
  oque é isso então no côdigo abaixo eu digo a ele que  o componente " txtResultado"
  e do tipo "TEdit" então como ele coenhece a classe "TEdit" ele entende que toda vez
  que eu chamar um  "txtResultado" no meu côdigo eu estou falando de um "TEdit" porque
  eu avisei isso a ele na sessão type abaixo usando a declaração:

  txtResultado: TEdit;

  como eu fiz com os outros componentes

}

type
  TForm1 = class(TForm)
    Label1: TLabel;
    txtNum1: TEdit;
    Label2: TLabel;
    txtNum2: TEdit;
    btSomar: TButton;
    btSubtrair: TButton;
    btnMultiplicar: TButton;
    btnDividir: TButton;
    Label3: TLabel;
    txtResultado: TEdit;
    procedure btSomarClick(Sender: TObject);
    procedure btSubtrairClick(Sender: TObject);
    procedure btnMultiplicarClick(Sender: TObject);
    procedure btnDividirClick(Sender: TObject);
  private
    { Declarando uma procedure que recebe um astring como parâmetro   }

    procedure calcularResultados(operacao: String);
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.btnDividirClick(Sender: TObject);
begin
  {evitando divisão por zero}
  if txtNum2.text = '0' then
    showMessage('Voê não pode dividir por zero')
  else
    calcularResultados('dividir');
end;

procedure TForm1.btnMultiplicarClick(Sender: TObject);
begin
  calcularResultados('multiplicar');
end;

procedure TForm1.btSomarClick(Sender: TObject);
begin
  calcularResultados('somar');
end;

procedure TForm1.btSubtrairClick(Sender: TObject);
begin
  calcularResultados('subtrair');
end;


{
  Na ver~sao anterior cada botão tinha o seu porprio procedimento
  agora com a refatoração eles vão chamar a função passando a operação
  desejada como paramtro então a função vai devolver o resultado
  assim eu evito repetição de côdigo
}

procedure TForm1.calcularResultados(operacao: String);
var
  num1,num2,resultado : Real;

begin

   num1 := StrToFloat(txtNum1.Text);
   num2 := StrToFloat(txtNum2.Text);

    {testando de forma procedural o paramtro recebido}

    if operacao = 'somar' then

       resultado := num1 + num2;

    if operacao = 'subtrair' then

       resultado := num1 - num2;

    if operacao = 'multiplicar' then

       resultado := num1 * num2;

    if operacao = 'dividir' then

       resultado := num1 / num2;


   txtResultado.Text := FloatToStr(resultado);

end;

end.
